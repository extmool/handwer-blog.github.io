<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Handwer&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.handwer-std.top/"/>
  <updated>2018-07-28T12:26:00.652Z</updated>
  <id>https://blog.handwer-std.top/</id>
  
  <author>
    <name>Handwer STD</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>洛谷P1892《[BOI2003]团伙》</title>
    <link href="https://blog.handwer-std.top/2018-07-28/Luogu-P1892/"/>
    <id>https://blog.handwer-std.top/2018-07-28/Luogu-P1892/</id>
    <published>2018-07-28T12:17:29.000Z</published>
    <updated>2018-07-28T12:26:00.652Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本题来自「2018 SDSC」Day 3 考试题目</p></blockquote><p><a href="https://www.luogu.org/problemnew/show/P1892" target="_blank" rel="noopener">题目链接</a></p><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>1920年的芝加哥，出现了一群强盗。如果两个强盗遇上了，那么他们要么是朋友，要么是敌人。而且有一点是肯定的，就是：</p><p>我朋友的朋友是我的朋友；</p><p>我敌人的敌人也是我的朋友。</p><p>两个强盗是同一团伙的条件是当且仅当他们是朋友。现在给你一些关于强盗们的信息，问你最多有多少个强盗团伙。</p><h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input/Output 格式 &amp; 样例"></a>Input/Output 格式 &amp; 样例</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件gangs.in的第一行是一个整数N(2&lt;=N&lt;=1000)，表示强盗的个数（从1编号到N）。 <br><br>第二行M(1&lt;=M&lt;=5000)，表示关于强盗的信息条数。 <br><br>以下M行，每行可能是<code>F p q</code>或是<code>E p q</code>（1&lt;=p q&lt;=N），F表示p和q是朋友，E表示p和q是敌人。<br><br>输入数据保证不会产生信息的矛盾。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件gangs.out只有一行，表示最大可能的团伙数。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">4</span><br><span class="line">E 1 4</span><br><span class="line">F 3 5</span><br><span class="line">F 4 6</span><br><span class="line">E 1 2</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>很显然这是一道并查集的题目</p><p>初始时我们把每一个人单独列为一个团伙</p><p>由题可得，这道题主要有如下合并方式：</p><ol><li>我的朋友是我的朋友</li><li>我的朋友的朋友是我的朋友</li><li>我的敌人的朋友是我的敌人</li><li>我的敌人的敌人是我的朋友</li></ol><p>那么我们要另开一个$Enemy[\ ]$数组，$Enemy[i]$表示 $i$ 的<strong>其中一个</strong>敌人</p><p>每次合并敌人的时候，先判断是否有记录过敌人：</p><ul><li>如果有，那么就把当前的敌人和记录的敌人合并在一个团伙里</li><li>如果没有，那么就把当前的敌人记录</li></ul><p>最后开一个数组$count[\ ]$进行统计</p><p><strong><big><big>这里要注意几个点：</big></big></strong></p><ol><li>开始时并查集数组要<strong>开两倍</strong>，因为你要把敌人和朋友存在一个数组里</li><li>合并敌人时要注意合并的不是敌人本身，而是$Find($敌人$)$</li><li>最后统计的时候也要统计$Find($敌人$)$</li></ol><p>对了，注意输入…<br><br>建议使用iostream…<br><br>别问我为什么会写上这句话</p><p><a href="https://imgse.com/i/53vhll" target="_blank" rel="noopener"><img src="https://s1.ax2x.com/2018/07/28/53vhll.png" alt="53vhll.png"></a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> U[MAXN * <span class="number">2</span>], Enemy[MAXN * <span class="number">2</span>], n, m;</span><br><span class="line"><span class="keyword">int</span> count[MAXN * <span class="number">2</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        putint(x / <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (U[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> U[x] = Find(U[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = Find(x), y = Find(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line">    U[x] = y;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"P1892.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n * <span class="number">2</span>; ++i) U[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'F'</span>: &#123;</span><br><span class="line">                Union(x, y);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'E'</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (Enemy[x] == <span class="number">0</span>) Enemy[x] = Find(y);</span><br><span class="line">                <span class="keyword">else</span> Union(y, Enemy[x]);</span><br><span class="line">                <span class="keyword">if</span> (Enemy[y] == <span class="number">0</span>) Enemy[y] = Find(x);</span><br><span class="line">                <span class="keyword">else</span> Union(x, Enemy[y]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++count[Find(i)];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (count[i]) ++cnt;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本题来自「2018 SDSC」Day 3 考试题目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1892&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="并查集" scheme="https://blog.handwer-std.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1821 《[USACO07FEB]银牛派对Silver Cow Party》</title>
    <link href="https://blog.handwer-std.top/2018-07-20/Luogu-P1821/"/>
    <id>https://blog.handwer-std.top/2018-07-20/Luogu-P1821/</id>
    <published>2018-07-20T04:57:21.000Z</published>
    <updated>2018-07-20T05:23:39.389Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>巧妙地把单终点最短路径问题转化为单源最短路径问题</p></blockquote><a id="more"></a><p><a href="https://www.luogu.org/problem/show?pid=1821" target="_blank" rel="noopener">题目地址</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>寒假到了，N头牛都要去参加一场在编号为X（1≤X≤N）的牛的农场举行的派对（1≤N≤1000），农场之间有M（1≤M≤100000）条有向路，每条路长Ti（1≤Ti≤100）。</p><p>每头牛参加完派对后都必须回家，无论是去参加派对还是回家，每头牛都会选择最短路径，求这N头牛的最短路径（一个来回）中最长的一条路径长度。</p><h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input/Output 格式 &amp; 样例"></a>Input/Output 格式 &amp; 样例</h1><p><strong>输入格式：</strong><br><br>第一行三个整数N，M, X；</p><p>第二行到第M+1行：每行有三个整数Ai，Bi, Ti ,表示有一条从Ai农场到Bi农场的道路，长度为Ti。</p><p><strong>输出格式：</strong><br><br>一个整数，表示最长的最短路得长度。</p><p><strong>输入样例#1：</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">4 8 2</span><br><span class="line">1 2 4</span><br><span class="line">1 3 2</span><br><span class="line">1 4 7</span><br><span class="line">2 1 1</span><br><span class="line">2 3 5</span><br><span class="line">3 1 2</span><br><span class="line">3 4 4</span><br><span class="line">4 2 3</span><br></pre></td></tr></table></figure></p><p><strong>输出样例#1：</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure></p><h1 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h1><p><img src="https://cdn.luogu.org/upload/pic/667.png" alt=""><br><br><small>图片来自洛谷</small></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>单源最短路我们都会做，一遍<code>SPFA</code>或<code>Dijkstra</code>就行了。</p><p>单终点最短路呢？</p><p>对于这道题，奶牛们从派对分别回家就是一个单源最短路问题，而奶牛们从家到派对就是一个单终点最短路问题。</p><p>如何把单终点最短路转化为单源最短路问题？<br>注意：题目中建的是有向边</p><p>实在是想不出来的我翻了一波题解，发现他们都在输入的时候另建了一个图，<big><strong>反向存边</strong></big>，就完美地把一个单终点最短路转化为单源最短路<br><br>因为单源和单终点的区别仅仅是<big><strong>方向改变</strong></big>，很显然这么做是对的</p><p>最后的答案是什么？<br><br>正向建图的距离+反向建图的距离的最大值</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>我们在数组后加上「Reversed」，表示它存的是反向的图</p><p><a href="https://www.luogu.org/record/show?rid=8666784" target="_blank" rel="noopener">评测记录 AC</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> prev;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">&#125; edge[MAXM], edgeReversed[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, x, cnt, maxWeight = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> dis[MAXN], head[MAXN], disReversed[MAXN], headReversed[MAXN];</span><br><span class="line"><span class="keyword">bool</span> inQueue[MAXN], inQueueReversed[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        (ch == <span class="string">'-'</span>) &amp;&amp; (x = <span class="number">-1</span>);</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdgeReversed</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">    edgeReversed[cnt].prev = prev;</span><br><span class="line">    edgeReversed[cnt].weight = weight;</span><br><span class="line">    edgeReversed[cnt].next = headReversed[next];</span><br><span class="line">    headReversed[next] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">    edge[++cnt].prev = prev;</span><br><span class="line">    edge[cnt].weight = weight;</span><br><span class="line">    edge[cnt].next = head[next];</span><br><span class="line">    head[next] = cnt;</span><br><span class="line">    addEdgeReversed(next, prev, weight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(inQueue, <span class="number">0</span>, <span class="keyword">sizeof</span>(inQueue));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) dis[i] = <span class="number">2147483647</span>;</span><br><span class="line">    <span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;, <span class="built_in">std</span>::greater&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &gt; q;</span><br><span class="line">    inQueue[s] = <span class="literal">true</span>;</span><br><span class="line">    q.push(make_pair(s, <span class="number">0</span>));</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = q.top().first;</span><br><span class="line">        <span class="keyword">int</span> weight = q.top().second;</span><br><span class="line">        q.pop();</span><br><span class="line">        inQueue[prev] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e = head[prev]; e; e = edge[e].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[edge[e].prev] &gt; edge[e].weight + weight) &#123;</span><br><span class="line">                dis[edge[e].prev] = edge[e].weight + weight;</span><br><span class="line">                q.push(make_pair(edge[e].prev, dis[edge[e].prev])); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DijkstraReversed</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(inQueueReversed, <span class="number">0</span>, <span class="keyword">sizeof</span>(inQueueReversed));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) disReversed[i] = <span class="number">2147483647</span>;</span><br><span class="line">    <span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;, <span class="built_in">std</span>::greater&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &gt; q;</span><br><span class="line">    inQueueReversed[s] = <span class="literal">true</span>;</span><br><span class="line">    q.push(make_pair(s, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = q.top().first;</span><br><span class="line">        <span class="keyword">int</span> weight = q.top().second;</span><br><span class="line">        q.pop();</span><br><span class="line">        inQueueReversed[prev] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e = headReversed[prev]; e; e = edgeReversed[e].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (disReversed[edgeReversed[e].prev] &gt; edgeReversed[e].weight + weight) &#123;</span><br><span class="line">                disReversed[edgeReversed[e].prev] = edgeReversed[e].weight + weight;</span><br><span class="line">                q.push(make_pair(edgeReversed[e].prev, disReversed[edgeReversed[e].prev])); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    n = getint(), m = getint(), x = getint();</span><br><span class="line">    <span class="keyword">int</span> tm = m;</span><br><span class="line">    <span class="keyword">while</span> (tm --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = getint(), next = getint(), weight = getint();</span><br><span class="line">        addEdge(prev, next, weight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tn = n;</span><br><span class="line">    Dijkstra(x, n);</span><br><span class="line">    DijkstraReversed(x, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        maxWeight = <span class="built_in">std</span>::max(maxWeight, dis[i] + disReversed[i]);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, maxWeight);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;巧妙地把单终点最短路径问题转化为单源最短路径问题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="最短路" scheme="https://blog.handwer-std.top/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="图论算法" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1149《火柴棒等式》</title>
    <link href="https://blog.handwer-std.top/2018-07-15/Luogu-P1149/"/>
    <id>https://blog.handwer-std.top/2018-07-15/Luogu-P1149/</id>
    <published>2018-07-15T13:41:54.000Z</published>
    <updated>2018-07-15T14:27:42.511Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>「枚举」的入门题目</p></blockquote><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/P1149" target="_blank" rel="noopener">题目地址</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你n根火柴棍，你可以拼出多少个形如$ A+B=C$的等式？等式中的 $A 、 B 、 C$ 是用火柴棍拼出的整数（若该数非零，则最高位不能是 $0$ ）。用火柴棍拼数字 $0-9$ 的拼法如图所示：</p><p><img src="https://cdn.luogu.org/upload/pic/49.png" alt="img"></p><center><small>图片来自洛谷</small></center><p>注意：</p><ol><li>加号与等号各自需要两根火柴棍</li><li>如果 $A≠B$ ，则 $A+B=C$ 与 $B+A=C$ 视为不同的等式( $A,B,C&gt;=0$ )</li><li>$n$ 根火柴棍必须全部用上</li></ol><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><p><strong>输入格式：</strong></p><p>一个整数 $n$($n&lt;=24$) 。</p><p><strong>输出格式：</strong></p><p>一个整数，能拼成的不同等式的数目。</p><p><strong>输入样例#1：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure></p><p><strong>输出样例#1：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></p><p><strong>输入样例#2：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18</span><br></pre></td></tr></table></figure></p><p><strong>输出样例#2：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure></p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>【输入输出样例1解释】</p><p>$2$ 个等式为 $0+1=1$ 和 $1+0=1$ 。</p><p>【输入输出样例2解释】</p><p>$9$ 个等式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0+4=4</span><br><span class="line">0+11=11</span><br><span class="line">1+10=11</span><br><span class="line">2+2=4</span><br><span class="line">2+7=9</span><br><span class="line">4+0=4</span><br><span class="line">7+2=9</span><br><span class="line">10+1=11</span><br><span class="line">11+0=11</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="枚举思路"><a href="#枚举思路" class="headerlink" title="枚举思路"></a>枚举思路</h2><p>我们可以枚举$A$和$B$</p><big><strong>上界？</strong></big><p>手算啊</p><p>$n&lt;=24$，去掉符号用的4根火柴棒，相当于是「$n&lt;=20$」</p><p>再$\frac{n}{2}$（这里只考虑有$A$和$B$两个数字），可得</p><blockquote><p>对于某一个数字，可调用的火柴棒共有10个</p></blockquote><p>由于使用火柴棒数量最少的$1$要使用2根，所以我们假设两个数字都为$11111$，但是显然这样是不成立的，因为$2\times5 + 2 * 5$就已经达到$20$了，没有火柴棒再放第三个数字，那么由此可粗略得出</p><blockquote><p>对于某一个数字，它最高有5位</p></blockquote><p>于是我们可以选择枚举到$9999$，洛谷的评测机上也不会TLE</p><p>当然CCF的老爷机就不一定了（</p><p>于是我们可以选择再精确一点</p><p>// 未完待<strong>续</strong></p><p>枚举之后相加，取出所用的火柴棒数，进行判断就好了</p><h2 id="预处理思路"><a href="#预处理思路" class="headerlink" title="预处理思路"></a>预处理思路</h2><p>火柴棒数怎么求？</p><p>新建一个数组 f[10000 * 2 + 10] ，表示i这个数字需要用f[i]根火柴</p><p>题目已经给出了f[0~9]，如何处理出f[10~(10000*2)]？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f[i] = f[i/<span class="number">10</span>] + f[i%<span class="number">10</span>]; <span class="comment">// (i &gt;= 10)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里的i/10可以取它除了个位上其他位的数，在前面已经处理过，</span></span><br><span class="line"><span class="comment">所以可以直接使用；这里的i%10可以取它个位上的数，也处理过，</span></span><br><span class="line"><span class="comment">可以直接使用。两个火柴棒数目一相加，就能获得火柴棒的总数。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>循环一遍就好了</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sticks[<span class="number">10001</span> * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">sticks[<span class="number">0</span>] = sticks[<span class="number">6</span>] = sticks[<span class="number">9</span>] = <span class="number">6</span>;</span><br><span class="line">sticks[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">sticks[<span class="number">2</span>] = sticks[<span class="number">3</span>] = sticks[<span class="number">5</span>] = <span class="number">5</span>;</span><br><span class="line">sticks[<span class="number">4</span>] = <span class="number">4</span>;</span><br><span class="line">sticks[<span class="number">7</span>] = <span class="number">3</span>;</span><br><span class="line">sticks[<span class="number">8</span>] = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &lt;= <span class="number">20000</span>; ++i) &#123;</span><br><span class="line">sticks[i] = sticks[i/<span class="number">10</span>] + sticks[i%<span class="number">10</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9999</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9999</span>; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (sticks[i] + <span class="number">2</span> + sticks[j] + <span class="number">2</span> + sticks[i+j] == n) ++sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;「枚举」的入门题目&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="枚举" scheme="https://blog.handwer-std.top/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>二分图匹配学习笔记 &amp; HDU2063 题解</title>
    <link href="https://blog.handwer-std.top/2018-07-06/BipartiteGraph/"/>
    <id>https://blog.handwer-std.top/2018-07-06/BipartiteGraph/</id>
    <published>2018-07-06T13:36:45.000Z</published>
    <updated>2018-07-06T13:47:57.998Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>二分图真是个奇怪又好玩的东西</p></blockquote><p>注：本文包含<a href="acm.hdu.edu.cn/showproblem.php?pid=2063">《HDU2063 过山车》</a>题解</p><a id="more"></a><h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>设图$G=(V,E)$是一个无向图，若顶点集合$V$可分割为两个互不相交的子集$X$和$Y$，且图中每条边连接的顶点一个在$X$中，一个在$Y$中，则称$G$是一个二分图。</p><h2 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h2><p>若某一图是联通的，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 任选一个点V作为顶点，定义距离标号为0</span><br><span class="line">2. 将V的邻接点标号设为1，接着将它的未标号的邻接点的标号设为2，以此类推 </span><br><span class="line">3. 将所有标号为奇数的点归为X，标号为偶数的点归为Y</span><br></pre></td></tr></table></figure><p>以上内容可以采用BFS完成</p><p>依次检查每一条边，看看是否满足顶点一个在$X$中，一个在$Y$中</p><hr><p>若某一图不连通，就在每个联通块里进行判定</p><h1 id="二分图匹配"><a href="#二分图匹配" class="headerlink" title="二分图匹配"></a>二分图匹配</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>给定一个二分图$G$，在$G$的子图$M$中，$M$的边集${E}$中的任意两条边都不依附于同一个顶点，则称$M$是一个匹配。</p><p>图中蓝色的边是数量为2的匹配</p><p><img src="https://s1.ax2x.com/2018/07/06/oQPHl.png" alt="oQPHl.png"></p><h2 id="最大匹配-amp-完全匹配"><a href="#最大匹配-amp-完全匹配" class="headerlink" title="最大匹配 &amp; 完全匹配"></a>最大匹配 &amp; 完全匹配</h2><p>选择边数最大的子图称为「二分图的最大匹配问题」</p><p>如果一个匹配中图的每一个顶点都和某条边相关联，则称此匹配为「完全匹配」（或「完备匹配」）</p><p>图中为一个完全匹配</p><p><img src="https://s1.ax2x.com/2018/07/06/oQa4J.png" alt="oQa4J.png"></p><h2 id="增广路径"><a href="#增广路径" class="headerlink" title="增广路径"></a>增广路径</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>设$M$为二分图$G$已匹配边的集合，若$P$是$G$上其中一条联通两个未匹配顶点的路径（起点在$X$部，终点在$Y$部），且属$M$的边和不属$M$的边在$P$上交替出现，则称$P$为相对于$M$的一条增广路径</p><h3 id="寻找增广路"><a href="#寻找增广路" class="headerlink" title="寻找增广路"></a>寻找增广路</h3><p>设$M$为二分图$G$所有已匹配边的集合，</p><p>如图，蓝色为在$M$里的边，黄色为不在$M$里的边</p><p><img src="https://s1.ax2x.com/2018/07/06/oW9gr.png" alt="oW9gr.png"></p><p>从$x_4$到$y_2$找一条路径：</p><p>$<br>x_4 \rightarrow y_3 \rightarrow x_2 \rightarrow y1 \rightarrow x1 \rightarrow y2<br>$</p><p>这条路径就是<strong>「增广路径」</strong></p><p>其中属于$M$的边有：<br>${x2,y3}, {x1,y1}$</p><p>不属于$M$的边有：<br>${x4,y3}, {x2,y1},{x1,y2}$</p><p>显然，<i><b>不属于$M$的边比属于$M$的边要多一条</b></i></p><hr><p>将这条增广路上的边全都「反色」，如图</p><p><img src="https://s1.ax2x.com/2018/07/06/oWBQY.png" alt="oWBQY.png"></p><p>可以发现，匹配仍然合法，但是匹配数多了一对</p><pre><code>另外，单独的一条连接两个未匹配点的边显然也是增广路   </code></pre><p>那么可知，当不能再找到增广轨时，就得到了一个「最大匹配」，这就是匈牙利算法的基本思路</p><h3 id="增广路径性质"><a href="#增广路径性质" class="headerlink" title="增广路径性质"></a>增广路径性质</h3><p>由增广路的定义可以推出下述三个结论：</p><ol><li>P的路径长度必定为奇数，第一条边和最后一条边都不属于M，因为两个端点分属两个集合，且未匹配。</li><li>P经过取反操作可以得到一个更大的匹配M’。</li><li>M为G的最大匹配当且仅当不存在相对于M的增广路径。</li></ol><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p>用增广路求最大匹配（称作匈牙利算法，匈牙利数学家Edmonds于1965年提出）</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>置$M$为空</li><li>找出一条增广路$P$，通过取反操作获得更大的匹配$M‘$代替$M$</li><li>重复2直到找不出增广路</li></ol><h3 id="找增广路径的算法"><a href="#找增广路径的算法" class="headerlink" title="找增广路径的算法"></a>找增广路径的算法</h3><p>我们采用DFS的办法找一条增广路径： </p><p>从X部一个未匹配的顶点u开始，找一个未访问的邻接点v（v一定是Y部顶点）。</p><p>对于$v$，分两种情况：</p><ol><li>如果$v$未匹配，则已经找到一条增广路</li><li>如果$v$已经匹配，则取出$v$的匹配顶点$w$($w$一定是$X$部顶点)，边$(w,v)$目前是匹配的，根据“取反”的想法，要将$(w,v)$改为未匹配，$(u,v)$设为匹配，能实现这一点的条件是看从$w$为起点能否新找到一条增广路径$P’$。如果行，则$u \rightarrow v \rightarrow P’$就是一条以$u$为起点的增广路径。</li></ol><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>mx[i]表示与X部i点匹配的Y部顶点编号 </p><p>my[i]表示与Y部i点匹配的X部顶点编号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span><span class="comment">//寻找从u出发的增广路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> each v∈u的邻接点</span><br><span class="line">        <span class="keyword">if</span>(v未访问)&#123;</span><br><span class="line">            标记v已访问;</span><br><span class="line">            <span class="keyword">if</span>(v未匹配||dfs(my[v]))&#123;</span><br><span class="line">                mx[u]=v;</span><br><span class="line">                my[v]=u; </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//有从u出发的增广路径</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//无法找到从u出发的增广路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="《HDU2063-过山车》题解"><a href="#《HDU2063-过山车》题解" class="headerlink" title="《HDU2063 过山车》题解"></a>《HDU2063 过山车》题解</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>RPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？</p><h2 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input/Output 格式 &amp; 样例"></a>Input/Output 格式 &amp; 样例</h2><p><strong>Input</strong></p><p>输入数据的第一行是三个整数$K , M , N$，分别表示可能的组合数目，女生的人数，男生的人数。$0&lt;K&lt;=1000,<br>1&lt;=N,M&lt;=500$.接下来的$K$行，每行有两个数，分别表示女生$A_i$愿意和男生$B_j$做partner。最后一个$0$结束输入。</p><p><strong>Output</strong></p><p>对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。</p><p><strong>Sample Input</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">6 3 3</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 1</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><p><strong>Sample Output</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>「每个女生必须找个个男生做partner和她同坐」</p><p>好了，可以看出这是匹配问题，问你如何匹配</p><p>「Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner」</p><p>这句话告诉了我们如何建边：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">把所有女生的顶点放到集合X中，所有男生的顶点放到集合Y中，</span><br><span class="line">从Rabbit分别建一条到XHD的边和一条到PQK的边，</span><br><span class="line">从Grass分别建一条到linle的边和一条到LL的边……</span><br></pre></td></tr></table></figure><p>那么显然这就是一个二分图，而本题要求的就是这个二分图的最大匹配</p><p>又是一道模板题</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t[MAXN][MAXN], <span class="built_in">map</span>[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k, m, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 核心代码</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[u][i] &amp;&amp; !vis[i]) &#123;</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">map</span>[i] || dfs(<span class="built_in">map</span>[i])) &#123;</span><br><span class="line">                <span class="built_in">map</span>[i] = u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;k, &amp;m, &amp;n), k != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="keyword">sizeof</span>(t));</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(<span class="built_in">map</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">map</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">            t[x][y] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">            <span class="keyword">if</span> (dfs(i)) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;二分图真是个奇怪又好玩的东西&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注：本文包含&lt;a href=&quot;acm.hdu.edu.cn/showproblem.php?pid=2063&quot;&gt;《HDU2063 过山车》&lt;/a&gt;题解&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="二分图" scheme="https://blog.handwer-std.top/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>2017 国庆清北刷题冲刺班 《角谷猜想》</title>
    <link href="https://blog.handwer-std.top/2018-07-04/Kakutani/"/>
    <id>https://blog.handwer-std.top/2018-07-04/Kakutani/</id>
    <published>2018-07-04T12:05:44.000Z</published>
    <updated>2018-07-06T13:41:08.641Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>不错的字符串模拟</p></blockquote><a id="more"></a><p>题目来自<a href="https://aor.sd.cn/problem/1006" target="_blank" rel="noopener">Air Begin</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>某个名字末尾是654321的小A同学是个大家眼中公认的学霸（虽然他永远不承认），他对题目的直觉到了一种可怕的地步，一眼看出题目的算法对他而言只是小 Case，他甚至能在看到一个证明的瞬间敏锐地判断出这个证明的真伪。</p><p>现在小A同学机缘巧合地看到了角古猜想（即对于$x$当它为奇数则$x=3x+1$,$x$为偶数，则$x=\frac{x}{2}$，一直重复这个步骤，则最终$x$会变为$1$），在看完这个猜想的一瞬间，他的直觉就来了——他认为角古猜想一定是错的！然后——他立刻就能找出反例！</p><p>他立刻在纸上写满了$n$($1&lt;=n&lt;=1000$)个小于$10^L$($0&lt;=L&lt;=10^4$)的正整数，打算放到他的grand super computer 上去跑，可是他突然觉得有些正整数不是很吉利，可能会干扰到他的最终结果，所以他打算把一些正整数加工一下。</p><p>小A觉得4、7、13都是不吉利的数字，所以要把所有正整数里的4、7、13都去掉，如果去掉后得到的新数字里依旧有4、7、13，那么就要继续删掉，直到最后的数组不存在4、7、13，它才是一个吉利的数字。例如$1411733=&gt;111733=&gt;11133=&gt;113=&gt;1$<br>特别规定，如果最后所有数字都被删掉了，就输出$0$<br>小A觉得这个枯燥的工作不适合他这样的天才，于是就把这个工作交给了你。</p><p>当然，只要你能顺利解决，小A承诺会在那篇将会震惊世界的论文的特别感谢栏上署上你的大名。</p><h2 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input/Output 格式 &amp; 样例"></a>Input/Output 格式 &amp; 样例</h2><p><strong>Input</strong></p><p>一共$n+1$行。</p><p>第一行一个正整数$n$($1&lt;=n&lt;=100$)，表示数字个数。</p><p>接下来每行一个正整数$x$。</p><p><strong>Output</strong></p><p>一共$n$行。</p><p>每行一个正整数，表示输入每个$x$对应的答案。</p><p><strong>Sample Input 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">13713</span><br><span class="line">141713</span><br><span class="line">1333333372589</span><br><span class="line">1411733</span><br><span class="line">2147483647</span><br></pre></td></tr></table></figure><p><strong>Sample Output1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">11</span><br><span class="line">3333332589</span><br><span class="line">1</span><br><span class="line">21836</span><br></pre></td></tr></table></figure><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于$10%$的数据，$0&lt;=x&lt;=2147483647$<br>对于另外的$10%$数据，给定的数字没有数码$3$<br>对于另外的$10%$数据，$n=1$<br>对于全部的数据，$n$($1&lt;=n&lt;=1000$)，$1&lt;=x&lt;=10^L$($0&lt;=L&lt;=10^4$)</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>「$1&lt;=x&lt;=10^L$($0&lt;=L&lt;=10^4$)」</p><p>显而易见的高精</p><p>进而联想到字符串模拟</p><p>这道题有两个点需要注意：</p><ul><li>顺序不能乱</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先执行删除4和7的操作，再执行删除13的操作</span><br></pre></td></tr></table></figure><ul><li>在删除13时要检查是否残留</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">样例里有一个数据1411733</span><br><span class="line">先删除4和7，得到11133</span><br><span class="line">再删除13，得到113</span><br><span class="line"></span><br><span class="line">假如只删除一次13，那么就会有残留的13出现</span><br><span class="line">所以要在删除之后进行检查，</span><br><span class="line">否则就需要递归，将13再次删除</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><a href="https://aor.sd.cn/status/c758e25f7995b52f5662fa42a25f384e" target="_blank" rel="noopener">评测记录 AC</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">string</span> <span class="title">eraseAll4s</span><span class="params">(<span class="built_in">string</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ret = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> len = x.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) <span class="keyword">if</span> (x[i] == <span class="string">'4'</span>) x[i] = <span class="string">'-'</span>; <span class="comment">// 删除的'4'用'-'表示</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) <span class="keyword">if</span> (<span class="built_in">isdigit</span>(x[i])) ret += x[i]; <span class="comment">// 采集存留的数字，组成一个新的字符串</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">string</span> <span class="title">eraseAll7s</span><span class="params">(<span class="built_in">string</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代码思想一样，不再赘述</span></span><br><span class="line">    <span class="built_in">string</span> ret = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> len = x.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) <span class="keyword">if</span> (x[i] == <span class="string">'7'</span>) x[i] = <span class="string">'-'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) <span class="keyword">if</span> (<span class="built_in">isdigit</span>(x[i])) ret += x[i];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">string</span> <span class="title">eraseAll13s</span><span class="params">(<span class="built_in">string</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ret = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> len = x.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x[i] == <span class="string">'1'</span> &amp;&amp; x[i+<span class="number">1</span>] == <span class="string">'3'</span>) x[i] = x[i+<span class="number">1</span>] = <span class="string">'-'</span>;</span><br><span class="line">        <span class="comment">// 注意这里要同时检测两个字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> b = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) <span class="keyword">if</span> (<span class="built_in">isdigit</span>(x[i])) ret += x[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 重新进行检查</span></span><br><span class="line">        <span class="keyword">if</span> (ret[i] == <span class="string">'1'</span> &amp;&amp; ret[i+<span class="number">1</span>] == <span class="string">'3'</span>) &#123;</span><br><span class="line">            b = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b) &#123;</span><br><span class="line">        ret = eraseAll13s(ret); <span class="comment">// 递归删除</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Modify</span><span class="params">(<span class="built_in">string</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ret = <span class="string">""</span>;</span><br><span class="line">    ret = eraseAll4s(x);</span><br><span class="line">    ret = eraseAll7s(ret);</span><br><span class="line">    ret = eraseAll13s(ret);</span><br><span class="line">    <span class="comment">// 进行删除</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="string">""</span>) ret = <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">string</span> v;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n --&gt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">           这里是一个比较神奇的 while()，</span></span><br><span class="line"><span class="comment">           效果相当于 for (int i = 0; i &lt; n; ++i)，</span></span><br><span class="line"><span class="comment">           但是会对n进行修改，下标也是从n-1到0</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Modify(v) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;不错的字符串模拟&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="字符串" scheme="https://blog.handwer-std.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="自测题" scheme="https://blog.handwer-std.top/tags/%E8%87%AA%E6%B5%8B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2330 《[SCOI2005]繁忙的都市》</title>
    <link href="https://blog.handwer-std.top/2018-07-04/Luogu-P2330/"/>
    <id>https://blog.handwer-std.top/2018-07-04/Luogu-P2330/</id>
    <published>2018-07-04T01:32:44.000Z</published>
    <updated>2018-07-06T13:42:37.451Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>接近裸的最小生成树</p></blockquote><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/P2330" target="_blank" rel="noopener">题目地址</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>城市C是一个非常繁忙的大都市，城市中的道路十分的拥挤，于是市长决定对其中的道路进行改造。城市C的道路是这样分布的：城市中有n个交叉路口，有些交叉路口之间有道路相连，两个交叉路口之间最多有一条道路相连接。这些道路是双向的，且把所有的交叉路口直接或间接的连接起来了。每条道路都有一个分值，分值越小表示这个道路越繁忙，越需要进行改造。但是市政府的资金有限，市长希望进行改造的道路越少越好，于是他提出下面的要求：</p><p>1．改造的那些道路能够把所有的交叉路口直接或间接的连通起来。 2．在满足要求1的情况下，改造的道路尽量少。 3．在满足要求1、2的情况下，改造的那些道路中分值最大的道路分值尽量小。</p><p>任务：作为市规划局的你，应当作出最佳的决策，选择那些道路应当被修建。</p><h2 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input/Output 格式 &amp; 样例"></a>Input/Output 格式 &amp; 样例</h2><p><strong>输入格式</strong>：</p><p>第一行有两个整数n,m表示城市有n个交叉路口，m条道路。</p><p>接下来m行是对每条道路的描述，u, v, c表示交叉路口u和v之间有道路相连，分值为c。(1≤n≤300，1≤c≤10000，1≤m≤50000)</p><p><strong>输出格式</strong>：</p><p>两个整数s, max，表示你选出了几条道路，分值最大的那条道路的分值是多少。</p><p>输入样例#1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2 3</span><br><span class="line">1 4 5</span><br><span class="line">2 4 7</span><br><span class="line">2 3 6</span><br><span class="line">3 4 8</span><br></pre></td></tr></table></figure></p><p>输出样例#1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 6</span><br></pre></td></tr></table></figure></p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>前面已经提到过，</p><p>$1 \le n \le 300, 1 \le c \le 10000, 1 \le m \le 50000$</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>「1．改造的那些道路能够把所有的交叉路口直接或间接的连通起来。」</p><p>显然这是一道<strong>最小生成树</strong>的题目</p><p>但是题目中并没有要求输出最小的总权值，而是要输出最长边边权</p><p>所以它和裸的最小生成树还是有一些区别的</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><a href="https://www.luogu.org/record/show?rid=8135156" target="_blank" rel="noopener">评测记录 AC</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">300</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> U[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> cntTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> prev, next, w;</span><br><span class="line">&#125; edge[MAXM * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sortCmp</span><span class="params">(Edge x, Edge y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.w &lt; y.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (U[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> U[x] = Find(U[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> treeAns = <span class="number">0</span>;</span><br><span class="line">    sort(edge + <span class="number">1</span>, edge + <span class="number">1</span> + m, sortCmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAXN; ++i) U[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> eprev = Find(edge[i].prev);</span><br><span class="line">        <span class="keyword">int</span> enext = Find(edge[i].next);</span><br><span class="line">        <span class="keyword">if</span> (eprev == enext) <span class="keyword">continue</span>;</span><br><span class="line">        treeAns += edge[i].w;</span><br><span class="line">        U[eprev] = enext;</span><br><span class="line">        ret = max(ret, edge[i].w); <span class="comment">// 更新权值</span></span><br><span class="line">        ++cntTree;</span><br><span class="line">        <span class="keyword">if</span> (cntTree == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    n = getint(), m = getint();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = getint(), next = getint(), w = getint();</span><br><span class="line">        edge[i].prev = v;</span><br><span class="line">        edge[i].next = next;</span><br><span class="line">        edge[i].w = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = Kruskal();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, n - <span class="number">1</span>, ans);</span><br><span class="line">    <span class="comment">// 显而易见，生成的树肯定有 n - 1 条边，所以直接输出 n - 1 就好</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;接近裸的最小生成树&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="并查集" scheme="https://blog.handwer-std.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="图论算法" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/"/>
    
      <category term="最小生成树" scheme="https://blog.handwer-std.top/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>最短路径算法</title>
    <link href="https://blog.handwer-std.top/2018-07-03/ShortestPath/"/>
    <id>https://blog.handwer-std.top/2018-07-03/ShortestPath/</id>
    <published>2018-07-03T14:37:41.000Z</published>
    <updated>2018-07-03T15:31:50.296Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>较简单的图论算法</p></blockquote><a id="more"></a><p>最短路算法有很多种，比较著名的有</p><ul><li>Bellman-Ford</li><li>SPFA（队列优化版 Bellman-Ford）</li><li>Dijkstra</li><li>Floyd（基于DP思想）</li></ul><p>其中 Floyd 只适用于多源最短路径，SPFA 和 Bellman-Ford 代码易于理解但是效率低，Dijkstra 效率高但是不适用于图中有负边权的情况</p><p><del>至于其他算法……我见过某个dalao用线段树写最短路</del></p><p>本文只介绍单源最短路径中的 SPFA 和 Dijkstra （ Bellman-Ford 由于速度慢于 SPFA 所以忽略）。</p><h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><p>SPFA 可以处理图含有负边权的情况，同时又因为它效率较低，所以它更适合处理稀疏图</p><p>这里给出数组版代码</p><p>代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXINT = <span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2500</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">6200</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, next, w;</span><br><span class="line">&#125;edge[MAXM * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> dis[MAXN];</span><br><span class="line"><span class="keyword">bool</span> inQueue[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  edge[++cnt].v = v;</span><br><span class="line">  edge[cnt].w = w;</span><br><span class="line">  edge[cnt].next = head[u];</span><br><span class="line">  head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i] = MAXINT;</span><br><span class="line">  dis[s] = <span class="number">0</span>;</span><br><span class="line">  inQueue[s] = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  q.push(s);</span><br><span class="line">  <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    inQueue[v] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = head[v]; e; e = edge[e].next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dis[edge[e].v] &gt; edge[e].w + dis[v]) &#123;</span><br><span class="line">        dis[edge[e].v] = edge[e].w + dis[v];</span><br><span class="line">        <span class="keyword">if</span> (!inQueue[edge[e].v]) &#123;</span><br><span class="line">            q.push(edge[e].v);</span><br><span class="line">            inQueue[edge[e].v] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m, s, t;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    n for the nodes' count</span></span><br><span class="line"><span class="comment">    m for the edges' count</span></span><br><span class="line"><span class="comment">    s for the start node</span></span><br><span class="line"><span class="comment">    t for the end node</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d\n"</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d\n"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">    addEdge(u, v, w);</span><br><span class="line">    addEdge(v, u, w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, SPFA(s, t, n));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><p>Dijkstra 不能解决图中有负边权的情况，算法效率较高，适合在不含负边权的稠密/稀疏图中使用</p><p>这里还是给出数组写法</p><p>代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp std::make_pair</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1000000</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Pair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> ch = getchar();</span><br><span class="line">  <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = -x;</span><br><span class="line">    ch = getchar();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">    s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">    ch = getchar();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, next, w;</span><br><span class="line">&#125;edge[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>, head[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> inQueue[MAXN];</span><br><span class="line"></span><br><span class="line">ll dis[MAXN]; <span class="comment">// dis[i] --&gt; the distance from i to n</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  edge[++num].v = v;</span><br><span class="line">  edge[num].w = w;</span><br><span class="line">  edge[num].next = head[u];</span><br><span class="line">  head[u] = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// s for start, t for end, n for the count of the nodes</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i] = INF;</span><br><span class="line">  <span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;, <span class="built_in">std</span>::greater&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &gt; q;</span><br><span class="line">  inQueue[s] = <span class="literal">true</span>;</span><br><span class="line">  dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  q.push(mp(s,<span class="number">0</span>)); </span><br><span class="line">  <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = q.top().first;</span><br><span class="line">    <span class="keyword">int</span> value = q.top().second;</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = head[v]; e; e = edge[e].next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dis[edge[e].v] &gt; value + edge[e].w) &#123;</span><br><span class="line">        dis[edge[e].v] = (value + edge[e].w) ; </span><br><span class="line">        q.push(mp(edge[e].v, dis[edge[e].v]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  n = getint(), m = getint();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">    x = getint(), y = getint(), z = getint();</span><br><span class="line">    addEdge(x, y, z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dijkstra(<span class="number">1</span>, n, n)); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;较简单的图论算法&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="图论算法" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1955 《[NOI2015]程序自动分析》</title>
    <link href="https://blog.handwer-std.top/2018-05-12/Luogu-P1955/"/>
    <id>https://blog.handwer-std.top/2018-05-12/Luogu-P1955/</id>
    <published>2018-05-12T02:58:56.000Z</published>
    <updated>2018-07-06T13:42:25.596Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>第一道NOI的题目</p></blockquote><a id="more"></a><h1 id="洛谷-P1955-题解"><a href="#洛谷-P1955-题解" class="headerlink" title="洛谷 P1955 题解"></a>洛谷 P1955 题解</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。</p><p>考虑一个约束满足问题的简化版本：假设x1,x2,x3…代表程序中出现的变量，给定n个形如xi=xj或xi≠xj的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：x1=x2,x2=x3,x3=x4,x4≠x1，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。</p><p>现在给出一些约束满足问题，请分别对它们进行判定。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>从文件prog.in中读入数据。</p><p>输入文件的第1行包含1个正整数t，表示需要判定的问题个数。注意这些问题之间是相互独立的。</p><p>对于每个问题，包含若干行：</p><p>第1行包含1个正整数n，表示该问题中需要被满足的约束条件个数。接下来n行，每行包括3个整数i,j,e，描述1个相等/不等的约束条件，相邻整数之间用单个空格隔开。若e=1，则该约束条件为xi=xj；若e=0，则该约束条件为xi≠xj；</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出到文件 prog.out 中。</p><p>输出文件包括t行。</p><p>输出文件的第 k行输出一个字符串“ YES” 或者“ NO”（不包含引号，字母全部大写），“ YES” 表示输入中的第k个问题判定为可以被满足，“ NO” 表示不可被满足。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入 #1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">1 2 1</span><br><span class="line">1 2 0</span><br><span class="line">2</span><br><span class="line">1 2 1</span><br><span class="line">2 1 1</span><br></pre></td></tr></table></figure></p><p>输出 #1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br></pre></td></tr></table></figure></p><p>输入 #2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">1 2 1</span><br><span class="line">2 3 1</span><br><span class="line">3 1 1</span><br><span class="line">4</span><br><span class="line">1 2 1</span><br><span class="line">2 3 1</span><br><span class="line">3 4 1</span><br><span class="line">1 4 0</span><br></pre></td></tr></table></figure></p><p>输出 #2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure></p><p>数据范围（图片来自洛谷）<br><img src="https://cdn.luogu.org/upload/pic/1503.png" alt="data"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>把题目中的「x1=x2」看做x1和x2在同一个集合里，「x1≠x2」看做x1和x2不在同一个集合里……</p><p>好了，显而易见这是道并查集的题目</p><p>读懂了题目，下手就很简单了</p><p>这里要注意：<br>「x1≠x2」是无法进行的操作（因为你不能强制他们不在同一个集合里！若非要实现，就又要维护一个数组），把它看成查询操作。</p><p>而且「x1=x2」类似的操作要先做，「x1≠x2」类似的操作要最后做（因为后者对集合没有影响，它是一个查询操作）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果你遇到了类似这样的数据：</span><br><span class="line">...</span><br><span class="line">1 2 0</span><br><span class="line">1 2 1</span><br><span class="line">...</span><br><span class="line">那么根据我们的思路， 「1 2 0」是一个查询操作，对集合没有影响，那么就相当于少了一个操作！</span><br><span class="line">必须要先进行「x1=x2」类似的合并操作，再做「x1≠x2」类似的查询操作</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><a href="https://www.luogu.org/record/show?rid=7256140" target="_blank" rel="noopener">90分代码 评测记录（未离散化）</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> U[MAXN], n, t;</span><br><span class="line"><span class="keyword">int</span> e[MAXN], e0[MAXN], x[MAXN], y[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 快读 */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = -x;</span><br><span class="line">ch = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">ch = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (U[x] == x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> U[x] = Find(U[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x = Find(x), y = Find(y);</span><br><span class="line"><span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line">U[x] = y;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n = getInt();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; ++i) &#123;</span><br><span class="line">U[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(e, <span class="number">0</span>, <span class="keyword">sizeof</span>(e));</span><br><span class="line"><span class="built_in">memset</span>(x, <span class="number">0</span>, <span class="keyword">sizeof</span>(x));</span><br><span class="line"><span class="built_in">memset</span>(y, <span class="number">0</span>, <span class="keyword">sizeof</span>(y));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">x[i] = getInt(), y[i] = getInt(), e[i] = getInt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 第一次做 「x1=y1」的合并操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> fe = e[i], fx = x[i], fy = y[i];</span><br><span class="line"><span class="keyword">if</span> (fe == <span class="number">1</span>) Union(fx, fy);</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//  第二次做 「x1≠y1」的查询操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> fe = e[i], fx = x[i], fy = y[i];</span><br><span class="line"><span class="keyword">if</span> (fe == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(Find(fx) == Find(fy)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">t = getInt();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span> (Main()) <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><right>——引自百度百科</right><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">离散化，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。</span><br><span class="line">通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小。例如：</span><br><span class="line">原数据：1,999,100000,15；处理后：1,3,4,2；</span><br><span class="line">原数据：&#123;100,200&#125;，&#123;20,50000&#125;，&#123;1,400&#125;；</span><br><span class="line">处理后：&#123;3,4&#125;，&#123;2,6&#125;，&#123;1,5&#125;；</span><br></pre></td></tr></table></figure></p><p>对一堆数据进行离散化，</p><ol><li>先排序 [ 推荐 std::sort() ]（针对有序序列进行离散化）</li><li>删除重复元素（节省空间）</li><li>对数据进行索引（最终目的）</li></ol><p>而其中我们要用到STL提供的pair来储存变量。pair提供一个包含两个数据成员的结构体模板，可以快速访问其中的元素，就像一个压缩包一样（  </p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><p><a href="https://www.luogu.org/record/show?rid=7260594" target="_blank" rel="noopener">AC代码 评测记录</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Pair pair<span class="meta-string">&lt;ll,ll&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">600000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> U[MAXN], n, t;</span><br><span class="line"><span class="keyword">int</span> e[MAXN], x[MAXN], y[MAXN];</span><br><span class="line"></span><br><span class="line">Pair p[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = -x;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">        s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (U[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> U[x] = Find(U[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = Find(x), y = Find(y);</span><br><span class="line">    U[x] = y;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">stlCmp</span><span class="params">(Pair x, Pair y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x.first &gt; y.first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Disc</span><span class="params">(Pair a[], <span class="keyword">int</span> A[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n*<span class="number">2</span> + <span class="number">1</span>, stlCmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n*<span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span> || a[i].first != a[i<span class="number">-1</span>].first) tot++;</span><br><span class="line">        A[a[i].second] = tot;</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getInt();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500010</span>; ++i) &#123;</span><br><span class="line">        U[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(e, <span class="number">0</span>, <span class="keyword">sizeof</span>(e));</span><br><span class="line">    <span class="built_in">memset</span>(x, <span class="number">0</span>, <span class="keyword">sizeof</span>(x));</span><br><span class="line">    <span class="built_in">memset</span>(y, <span class="number">0</span>, <span class="keyword">sizeof</span>(y));</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> ax = getInt(), ay = getInt(), ae = getInt();</span><br><span class="line">        e[i] = ae;</span><br><span class="line">        p[i] = make_pair(ax, i);</span><br><span class="line">        p[i + n] = make_pair(ay, i+n);</span><br><span class="line">    &#125;</span><br><span class="line">    Disc(p, x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) y[i] = x[n + i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> fe = e[i], fx = x[i], fy = y[i];</span><br><span class="line">        <span class="keyword">if</span> (fe == <span class="number">1</span>) Union(fx, fy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> fe = e[i], fx = x[i], fy = y[i];</span><br><span class="line">        <span class="keyword">if</span> (fe == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Find(fx) == Find(fy)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    t = getInt();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Main()) <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;第一道NOI的题目&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="并查集" scheme="https://blog.handwer-std.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="NOI" scheme="https://blog.handwer-std.top/tags/NOI/"/>
    
  </entry>
  
  <entry>
    <title>并查集模板</title>
    <link href="https://blog.handwer-std.top/2018-04-14/union-set/"/>
    <id>https://blog.handwer-std.top/2018-04-14/union-set/</id>
    <published>2018-04-14T13:47:27.000Z</published>
    <updated>2018-06-23T00:17:15.697Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>并查集模板</p></blockquote><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/P3367" target="_blank" rel="noopener">题目链接</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>如题，现在有一个并查集，你需要完成合并和查询操作。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><p><strong>输入格式</strong>：</p><p>第一行包含两个整数N、M，表示共有N个元素和M个操作。</p><p>接下来M行，每行包含三个整数Zi、Xi、Yi</p><p>当Zi=1时，将Xi与Yi所在的集合合并</p><p>当Zi=2时，输出Xi与Yi是否在同一集合内，是的话输出Y；否则话输出N</p><p><strong>输出格式</strong>：</p><p>如上，对于每一个Zi=2的操作，都有一行输出，每行包含一个大写字母，为Y或者N</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入输出样例1"><a href="#输入输出样例1" class="headerlink" title="输入输出样例1"></a>输入输出样例1</h2><p>input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 7</span><br><span class="line">2 1 2</span><br><span class="line">1 1 2</span><br><span class="line">2 1 2</span><br><span class="line">1 3 4</span><br><span class="line">2 1 4</span><br><span class="line">1 2 3</span><br><span class="line">2 1 4</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">N</span><br><span class="line">Y</span><br><span class="line">N</span><br><span class="line">Y</span><br></pre></td></tr></table></figure><h1 id="数据说明"><a href="#数据说明" class="headerlink" title="数据说明"></a>数据说明</h1><p>时空限制：1000ms,128M</p><p>数据规模：</p><p>对于30%的数据，N&lt;=10，M&lt;=20；</p><p>对于70%的数据，N&lt;=100，M&lt;=1000；</p><p>对于100%的数据，N&lt;=10000，M&lt;=200000。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> U[MAXN], m, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (U[x] &lt; <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> U[x] = Find(U[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x = Find(x), y = Find(y);</span><br><span class="line"><span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line">U[x] += U[y];</span><br><span class="line">U[y] = x; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; MAXN;i++) U[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> z;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;z);</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">switch</span>(z) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">Union(x, y);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line"><span class="keyword">if</span> (Find(x) == Find(y)) <span class="built_in">puts</span>(<span class="string">"Y"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"N"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;并查集模板&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="模板" scheme="https://blog.handwer-std.top/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1536 《村村通》</title>
    <link href="https://blog.handwer-std.top/2018-04-14/Luogu-P1536/"/>
    <id>https://blog.handwer-std.top/2018-04-14/Luogu-P1536/</id>
    <published>2018-04-14T13:43:58.000Z</published>
    <updated>2018-07-06T13:42:10.632Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>并查集的好题目</p></blockquote><a id="more"></a><p><a href="https://www.luogu.org/problem/show?pid=1536" target="_blank" rel="noopener">题目地址</a> </p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>某市调查城镇交通状况，得到现有城镇道路统计表。表中列出了每条道路直接连通的城镇。市政府“村村通工程”的目标是使全市任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要相互之间可达即可）。请你计算出最少还需要建设多少条道路？</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><p><strong>输入格式：</strong><br>每个输入文件包含若干组测试测试数据，每组测试数据的第一行给出两个用空格隔开的正整数，分别是城镇数目N（N&lt;1000）和道路数目M；随后的M行对应M条道路，每行给出一对用空格隔开的正整数，分别是该条道路直接相连的两个城镇的编号。简单起见，城镇从1到N编号。</p><p>注意：两个城市间可以有多条道路相通。例如：</p><p>3 3 1 2 1 2 2 1 这组数据也是合法的。当N为0时，输入结束。</p><p><strong>输出格式：</strong><br>对于每组数据，对应一行一个整数。表示最少还需要建设的道路数目。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br><span class="line">1 3</span><br><span class="line">4 3</span><br><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">5 2</span><br><span class="line">1 2</span><br><span class="line">3 5</span><br><span class="line">999 0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">998</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这是道并查集的题目，可以说接近是裸的并查集，但是你没法把这题理解为并查集这就很烦了啊喂</p><p>我们可以把它的公路理解成一条一条绳子，用来连接各个城市，可以把几个城市绑在一块（雾 </p><p>那么这样就更像并查集了</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_CERR(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">'='</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> u[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u[x] &lt; <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> u[x] = Find(u[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x = Find(x), y = Find(y);</span><br><span class="line"><span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line">u[x] += u[y];</span><br><span class="line">u[y] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m) == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; MAXN;i++) u[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">a = Find(a), b = Find(b);</span><br><span class="line"><span class="keyword">if</span> (a != b) Union(a, b); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (u[i] &lt; <span class="number">0</span>) ans++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.org/record/show?rid=6799967" target="_blank" rel="noopener">提交记录</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;并查集的好题目&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="并查集" scheme="https://blog.handwer-std.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>线段树 模板</title>
    <link href="https://blog.handwer-std.top/2018-04-01/segmenttree/"/>
    <id>https://blog.handwer-std.top/2018-04-01/segmenttree/</id>
    <published>2018-03-31T16:26:09.000Z</published>
    <updated>2018-06-23T00:17:15.681Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>快速查找和修改区间</p></blockquote><p>注意：本文包含<a href="https://www.luogu.org/problemnew/show/P3372" target="_blank" rel="noopener">洛谷 P3372 【模板】线段树 1</a> 题解</p><a id="more"></a><h1 id="线段树模板"><a href="#线段树模板" class="headerlink" title="线段树模板"></a>线段树模板</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>什么是线段树？</li></ul><p>线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。</p><ul><li>线段树的主要用途及好处？</li></ul><p>线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。</p><ul><li>线段树的应用？</li></ul><p>最简单的应用就是记录线段是否被覆盖，随时查询当前被覆盖线段的总长度。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h3><p>我们选择一个$O(1)$的取儿子函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左子树 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右子树</span></span><br></pre></td></tr></table></figure><p>线段树的维护：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">t[p] = t[leftChild(p)] + t[rightChild(p)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向上维护区间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUpMin</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">t[p] = <span class="built_in">std</span>::min(t[leftChild(p)], t[rightChild(p)]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 向t[p]下放Min标签</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUpMax</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">t[p] = <span class="built_in">std</span>::max(t[leftChild(p)], t[rightChild(p)]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 向t[p]下放Max标签</span></span><br></pre></td></tr></table></figure><p>递归建树：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(lli p, lli l, lli r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">ans[p] = a[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果左右区间相同，则必是叶子节点</span></span><br><span class="line">lli mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">buildTree(leftChild(p), l, mid);</span><br><span class="line">buildTree(rightChild(p), mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line">pushUp(p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 递归 + 二分建树</span></span><br></pre></td></tr></table></figure><h3 id="区间修改函数"><a href="#区间修改函数" class="headerlink" title="区间修改函数"></a>区间修改函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Record</span><span class="params">(lli p, lli l, lli r, lli k)</span> </span>&#123;</span><br><span class="line">tag[p] = tag[p] + k;</span><br><span class="line">ans[p] = ans[p] + k * (r - l + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 因为是区间统一改变，所以ans要加元素个数 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 记录当前节点所代表的区间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(lli p, lli l, lli r)</span> </span>&#123;</span><br><span class="line">lli mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">Record(leftChild(p), l, mid, tag[p]);</span><br><span class="line">Record(rightChild(p), mid + <span class="number">1</span>, r, tag[p]);</span><br><span class="line">tag[p] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 每次更新两个儿子节点，不断向下传递 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(lli nl, lli nr, lli l, lli r, lli p, lli k)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 将要修改从 nl 到 nr 的区间</span></span><br><span class="line"><span class="comment">// l,r 为当前节点所储存的区间 </span></span><br><span class="line"><span class="comment">// p 为当前节点的编号</span></span><br><span class="line"><span class="keyword">if</span> (nl &lt;= l &amp;&amp; r &lt;= nr) &#123;</span><br><span class="line">ans[p] += k * (r - l + <span class="number">1</span>);</span><br><span class="line">tag[p] += k;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line">pushDown(p, l, r);</span><br><span class="line">lli mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (nl &lt;= mid) update(nl, nr, l, mid, leftChild(p), k)</span><br><span class="line"><span class="keyword">if</span> (nr &gt; mid) update(nl, nr,mid + <span class="number">1</span>, r, rightChild(p), k);</span><br><span class="line">pushUp(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新区间</span></span><br></pre></td></tr></table></figure><h3 id="查询区间函数"><a href="#查询区间函数" class="headerlink" title="查询区间函数"></a>查询区间函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> lli <span class="title">query</span><span class="params">(lli qx, lli qy, lli l, lli r, lli p)</span> </span>&#123;</span><br><span class="line">lli res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (qx &lt;= l &amp;&amp; r &lt;= qy) <span class="keyword">return</span> ans[p];</span><br><span class="line">lli mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">pushDown(p, l, r);</span><br><span class="line"><span class="keyword">if</span> (qx &lt;= mid) res += query(qx, qy, l, mid, leftChild(p));</span><br><span class="line"><span class="keyword">if</span> (mid + <span class="number">1</span> &lt;= qy) res += query(qx, qy, mid + <span class="number">1</span>, r, rightChild(p));</span><br><span class="line"><span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询区间</span></span><br></pre></td></tr></table></figure><p>依然采用二分的形式…</p><h1 id="洛谷-P3372-题解"><a href="#洛谷-P3372-题解" class="headerlink" title="洛谷 P3372 题解"></a>洛谷 P3372 题解</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知一个数列，你需要进行下面两种操作：</p><p>1.将某区间每一个数加上x</p><p>2.求出某区间每一个数的和</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个整数N、M，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含N个用空格分隔的整数，其中第i个数字表示数列第i项的初始值。</p><p>接下来M行每行包含3或4个整数，表示一个操作，具体如下：</p><p>操作1： 格式：1 x y k 含义：将区间[x,y]内每个数加上k</p><p>操作2： 格式：2 x y 含义：输出区间[x,y]内每个数的和</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出包含若干行整数，即为所有操作2的结果。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 5 4 2 3</span><br><span class="line">2 2 4</span><br><span class="line">1 2 3 2</span><br><span class="line">2 3 4</span><br><span class="line">1 1 5 1</span><br><span class="line">2 1 4</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11</span><br><span class="line">8</span><br><span class="line">20</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>就是把上面的函数都复制下来就行了= =</p><p>没什么多解释的</p><p>注释见上面代码</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// using namespace std;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">ull n, m, a[MAXN], ans[MAXN &lt;&lt; <span class="number">2</span>], tag[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">ls</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &lt;&lt; <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">rs</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scan</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">ans[p] = ans[ls(p)] + ans[rs(p)];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(ll p, ll l, ll r)</span> </span>&#123;</span><br><span class="line">tag[p] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">ans[p] = a[l];</span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line">ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build(ls(p), l, mid);</span><br><span class="line">build(rs(p), mid + <span class="number">1</span>, r);</span><br><span class="line">pushUp(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rec</span><span class="params">(ll p, ll l, ll r, ll k)</span> </span>&#123;</span><br><span class="line">tag[p] = tag[p] + k;</span><br><span class="line">ans[p] = ans[p] + k * (r - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(ll p,ll l, ll r)</span> </span>&#123;</span><br><span class="line">ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">rec(ls(p), l, mid, tag[p]);</span><br><span class="line">rec(rs(p), mid + <span class="number">1</span>, r, tag[p]);</span><br><span class="line">tag[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(ll nl, ll nr, ll l, ll r, ll p, ll k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nl &lt;= l &amp;&amp; r &lt;= nr) &#123;</span><br><span class="line">ans[p] += k * (r - l + <span class="number">1</span>);</span><br><span class="line">tag[p] += k;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">pushDown(p, l, r);</span><br><span class="line">ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (nl &lt;= mid) update(nl, nr, l, mid, ls(p), k);</span><br><span class="line"><span class="keyword">if</span> (nr &gt; mid) update(nl, nr, mid + <span class="number">1</span>, r, rs(p), k);</span><br><span class="line">pushUp(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll qx, ll qy, ll l, ll r, ll p)</span> </span>&#123;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (qx &lt;= l &amp;&amp; r &lt;= qy) <span class="keyword">return</span> ans[p];</span><br><span class="line">ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">pushDown(p, l, r);</span><br><span class="line"><span class="keyword">if</span> (qx &lt;= mid) res += query(qx, qy, l, mid, ls(p));</span><br><span class="line"><span class="keyword">if</span> (qy &gt; mid) res += query(qx, qy, mid + <span class="number">1</span>, r, rs(p));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// ios::sync_with_stdio(false);</span></span><br><span class="line">ll a1, b, c, d, e, f;</span><br><span class="line">scan();</span><br><span class="line">build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a1);</span><br><span class="line"><span class="keyword">switch</span>(a1) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>, &amp;b, &amp;c, &amp;d);</span><br><span class="line">update(b, c, <span class="number">1</span>, n, <span class="number">1</span>, d);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>, &amp;e, &amp;f);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(e, f, <span class="number">1</span>, n, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意一下，stdio 和 iostream 混用会出现很多奇怪的bug！</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;快速查找和修改区间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意：本文包含&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3372&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷 P3372 【模板】线段树 1&lt;/a&gt; 题解&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="模板" scheme="https://blog.handwer-std.top/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="线段树" scheme="https://blog.handwer-std.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>计算π</title>
    <link href="https://blog.handwer-std.top/2018-03-31/calculating-pi/"/>
    <id>https://blog.handwer-std.top/2018-03-31/calculating-pi/</id>
    <published>2018-03-31T15:18:59.000Z</published>
    <updated>2018-06-23T00:17:15.585Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算$π$可不是件容易事</p></blockquote><a id="more"></a><h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>偶然在WA谷上看到一道题</p><p><img src="https://s1.ax2x.com/2018/04/01/tlUNK.png" alt="tlUNK.png"></p><p>不得不说很玄学</p><p>抱着好奇的心态我点开了题解</p><p>发现了一个打表的。。。。</p><p>于是心血来潮去搜了一下如何计算π</p><p>于是就有了这篇文章</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Handwer STD 要你计算一下圆周率，要求最少为4000位（从小数部分第一位开始算起）</p><h1 id="输入描述-amp-样例"><a href="#输入描述-amp-样例" class="headerlink" title="输入描述&amp;样例"></a>输入描述&amp;样例</h1><p>无输入</p><h1 id="输出描述-amp-样例"><a href="#输出描述-amp-样例" class="headerlink" title="输出描述&amp;样例"></a>输出描述&amp;样例</h1><p>输出$π$，要求保留<strong>至少</strong>4000位小数。</p><p>样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3141592653589793......</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>时限为5000ms</p><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我们需要找到一个合适、可靠且快速的圆周率计算公式</p><p>我选择了基于级数的快速收敛公式</p><p>这是一个很快、精度也很高的算法</p><p>公式为：</p><p><img src="https://s1.ax2x.com/2018/04/01/tlkra.png" alt="tlkra.png"></p><p>（懒得写MathJax码了</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n = <span class="number">16366</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[<span class="number">16366</span> + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">double</span> cost;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>  i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n - i) d[++i] = <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">for</span> (;n;n -= <span class="number">14</span>) &#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> p;</span><br><span class="line"><span class="keyword">for</span> (p = <span class="number">0</span>,i = n;i;i--) &#123;</span><br><span class="line">p = p * i + d[i] * <span class="number">10000</span>;</span><br><span class="line">d[i] = p % (<span class="number">2</span> * i - <span class="number">1</span>);</span><br><span class="line">p /= <span class="number">2</span> * i - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.4d"</span>,d[<span class="number">0</span>] + p / <span class="number">10000</span>);</span><br><span class="line">d[<span class="number">0</span>] = p % <span class="number">10000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;计算$π$可不是件容易事&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数学" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>C++ 快速读入 模板</title>
    <link href="https://blog.handwer-std.top/2018-03-23/CPP-Fast-RW/"/>
    <id>https://blog.handwer-std.top/2018-03-23/CPP-Fast-RW/</id>
    <published>2018-03-23T11:40:02.000Z</published>
    <updated>2018-06-23T00:17:15.597Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>比某记者还快！</p></blockquote><a id="more"></a><h2 id="C-快速读入、输出"><a href="#C-快速读入、输出" class="headerlink" title="C++ 快速读入、输出"></a>C++ 快速读入、输出</h2><h4 id="在-C-上实现快速读入模板，这里是一个读取int-的示例。"><a href="#在-C-上实现快速读入模板，这里是一个读取int-的示例。" class="headerlink" title="在 C++ 上实现快速读入模板，这里是一个读取int 的示例。"></a>在 C++ 上实现快速读入模板，这里是一个读取int 的示例。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Quick_Read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt;= <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) w = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) s = s * <span class="number">10</span> + ch - <span class="string">'0'</span> , ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 本代码来自 wyh's Blog</span></span><br><span class="line"><span class="comment">// 地址: aor.sd.cn</span></span><br></pre></td></tr></table></figure><hr><h4 id="在-C-上实现快速输出模板，这里是一个输出int-的示例。"><a href="#在-C-上实现快速输出模板，这里是一个输出int-的示例。" class="headerlink" title="在 C++ 上实现快速输出模板，这里是一个输出int 的示例。"></a>在 C++ 上实现快速输出模板，这里是一个输出int 的示例。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Quick_Write</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">    re = -re;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断负数</span></span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">9</span>) Quick_Write(x/<span class="number">10</span>);</span><br><span class="line">  <span class="comment">// 判断是否大于10</span></span><br><span class="line">  <span class="built_in">putchar</span>(x%<span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;比某记者还快！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>矩阵乘法</title>
    <link href="https://blog.handwer-std.top/2018-03-10/matrix-mul/"/>
    <id>https://blog.handwer-std.top/2018-03-10/matrix-mul/</id>
    <published>2018-03-10T13:07:06.000Z</published>
    <updated>2018-06-23T00:17:15.669Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“简单”的矩阵乘法</p></blockquote><a id="more"></a><p>矩阵乘法，就是将两个矩阵相乘</p><p><img src="https://s1.ax2x.com/2018/03/10/EThWN.png" alt="EThWN.png"></p><p>现要求写一个程序，可以实现矩阵相乘。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行三个正整数 $n$、$p$、$m$，表示矩阵的长宽。<br>之后的$n$ 行，每行 $p$ 个整数，表示矩阵 $A$。<br>之后的 $p$ 行，每行 $m$ 个整数，表示矩阵 $B$。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出 $n$ 行，每行 $m$ 个整数，表示矩阵 $A×B$ ，每个数模 $10 ^ 9 + 7$ 输出。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3 4 5</span><br><span class="line">-2 -8 -9 8</span><br><span class="line">-10 0 6 -8</span><br><span class="line">-10 -6 6 9</span><br><span class="line">4 -7 5 -5 9</span><br><span class="line">10 -2 -10 5 5</span><br><span class="line">-3 -7 -3 8 -2</span><br><span class="line">-6 7 7 3 -2</span><br></pre></td></tr></table></figure><p><strong>良心数据</strong></p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">999999898 149 153 999999929 999999951</span><br><span class="line">999999997 999999979 999999883 74 999999921                                                 </span><br><span class="line">999999835 103 55 95 999999857</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">505</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD  = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">LL arr[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line"><span class="comment">// 重载运算符</span></span><br><span class="line">      Matrix res;</span><br><span class="line"><span class="built_in">memset</span>(res.arr,<span class="number">0</span>,<span class="keyword">sizeof</span>(res.arr));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; b.m;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; m;k++)&#123;</span><br><span class="line">(res.arr[i][j] += arr[i][k] * b.arr[k][j] % MOD) %= MOD;</span><br><span class="line">&#125;</span><br><span class="line">res.n = n;res.m = b.m;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;a,b,ans;</span><br><span class="line"><span class="comment">// 用结构体来储存矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,p,m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;p,&amp;m);</span><br><span class="line"></span><br><span class="line">a.n = n;a.m = p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; p;j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a.arr[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输入矩阵</span></span><br><span class="line">b.n = p;b.m = m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; p;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;b.arr[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ans = a * b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m - <span class="number">1</span>;j++)&#123;</span><br><span class="line">    (ans.arr[i][j] += MOD) %= MOD;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld "</span>,ans.arr[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">(ans.arr[i][m - <span class="number">1</span>] += MOD) %= MOD;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans.arr[i][m - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出矩阵</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><small>图片 by <a href="https://simimg.com/" target="_blank" rel="noopener">simimg.com</a> </small></center>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“简单”的矩阵乘法&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Windows 10 体验记</title>
    <link href="https://blog.handwer-std.top/2018-03-05/windows10/"/>
    <id>https://blog.handwer-std.top/2018-03-05/windows10/</id>
    <published>2018-03-05T13:48:11.000Z</published>
    <updated>2018-06-23T00:17:15.709Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Windows 10 从入门到放弃到重拾再到（伪）精通</p></blockquote><a id="more"></a><p>终于把Windows 10 的更新配置好了，再也不用5分钟开机了（</p><p>先把方法记一下吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. DiskGenius 激活Windows分区（默认激活deepin 根目录分区）</span><br><span class="line">2. 重启之后引导就炸了</span><br><span class="line">3. （进入Windows）使用 EasyBCD 重建Windows引导（可以不添加deepin）</span><br><span class="line">4. 重启之后引导还是爆炸的</span><br><span class="line">5. （进入deepin）执行 sudo grub-install /dev/sda &amp;&amp; sudo update-grub</span><br><span class="line">6. 重启之后还是deepin的grub引导，但是活动分区是Windows的</span><br><span class="line">7. 下载Fall Creators更新</span><br><span class="line">8. 安装更新</span><br><span class="line">9. 正常使用</span><br></pre></td></tr></table></figure></p><p>全程惊悚…</p><h2 id="2018-3-5"><a href="#2018-3-5" class="headerlink" title="2018.3.5"></a>2018.3.5</h2><p>Windows 10 可以正常使用的第一天，同时今天也开学了QAQ</p><p>开学什么的，体验最差了，况且今天还有什么收心考试</p><p>好在今天作业少，终于有时间写代码了（ · v · ）</p><p>用 Dev-C++ 写了 <strong>P1179 P1420 P1567</strong> 这两道大水题</p><p>总体感觉还是不错的</p><p>Dev-C++ 界面还行，还能看</p><p><img src="https://s1.ax2x.com/2018/03/13/L0Uea.jpg" alt="L0Uea.jpg"></p><p>后台开着一个火萤桌面，一个Chrome和一个Markdown编辑器</p><p>不得不说 Dev-C++ 真的是轻量级，占的内存从不超过100MB，Atom开完100MB就没了 对于这种老爷机真的很有用</p><blockquote><p>我好像可以Wine一个Dev-C++出来…但是不能编译</p></blockquote><p>这次体验感觉还不错，或许我可以主力一段时间…</p><h2 id="2018-3-13"><a href="#2018-3-13" class="headerlink" title="2018.3.13"></a>2018.3.13</h2><p>已经是深夜了，洗漱完又上洛谷打了个卡，写了一道<strong>入门难度</strong>的大水题</p><p>周六因为晚上需要写《矩阵乘法》，所以就没更这篇文章</p><p>（话说这个矩阵乘法耗了我一下午…我可能真的太弱了</p><p>周六我全天都在使用 Windows 10，除了更 Blog 需要重启到Linux </p><p>这几天体验下来，感觉还不错，态度慢慢好转</p><p>Windows 10 的触摸板手势真的爽！Deepin 15 的触摸板手势太不灵敏了，经常误触或无效操作<br>全靠友商衬托.png</p><p>（主要是 Windows 10 的电源调配真的比 Linux 好…耗电比 Linux 少</p><p>我现在已经是 Windows 10 主力了，Linux 用来更 Blog</p><p>等鼓捣好 Windows Subsystem for Linux （WSL） 之后应该就可以在 Windows 10 上更博客了<br>微软强势拉用户.jpg</p><h2 id="2018-3-14"><a href="#2018-3-14" class="headerlink" title="2018.3.14"></a>2018.3.14</h2><p>今天作业少 哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈</p><p>我在学校就完成了几乎全部的作业，到家就只剩下5个小题</p><p>做完作业后便欢欢喜喜地来搞 Windows Subsystem for Linux（WSL）</p><p>经过不懈的努力（其实就是重启一次）终于弄好了WSL</p><p>现在正在装 g++ </p><p>网慢死了QAQ</p><p><img src="https://s1.ax2x.com/2018/03/14/LUlOu.jpg" alt="g++.jpg"></p><center><small>PS：由于我没有截任务栏，所以比例有点奇怪</small></center><p>又用 Dev-C++ 写了一道记忆化搜索的大水题，感觉 Dev-C++ 比 Atom 好用多了，毕竟 Core i3 3110m 带不起 Atom</p><p>本来打算今天的 Blog 用 WSL 交，想想还是算了吧，出现意外没时间处理</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Windows 10 从入门到放弃到重拾再到（伪）精通&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="记录" scheme="https://blog.handwer-std.top/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>二分查找&amp;二分答案</title>
    <link href="https://blog.handwer-std.top/2018-02-06/BSAnswer/"/>
    <id>https://blog.handwer-std.top/2018-02-06/BSAnswer/</id>
    <published>2018-02-06T08:48:20.000Z</published>
    <updated>2018-06-23T00:17:15.577Z</updated>
    
    <content type="html"><![CDATA[<p>友情提示：先看二分查找，再看二分答案！</p><a id="more"></a><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="百度百科原话"><a href="#百度百科原话" class="headerlink" title="百度百科原话"></a>百度百科原话</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</span><br></pre></td></tr></table></figure><p>二分查找的时间复杂度是$O(log_{2}n)$</p><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul><li>查找的序列必须采用顺序存储结构</li></ul><ul><li>查找的序列必须是有序排列的</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li><p>将需要查找的序列进行排序（一般为升序排列）</p></li><li><p>将序列中间位置记录的元素与关键字比较</p></li><li><p>如果相等，则<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果不相等，则```将序列分成左右两个子序列，若元素小于关键字，就到左子序列中查找；否则就到右子序列中查找</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> t,<span class="keyword">int</span> x[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x[mid] == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (x[mid] &lt; t) l = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x[mid] &gt; t) r = mid - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> dest;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; dest;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">cin</span> &gt;&gt; p[i];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,BinarySearch(<span class="number">0</span>,n - <span class="number">1</span>,dest,p)?<span class="string">"YES"</span>:<span class="string">"NO"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h2><p>看完了二分查找，你会发现二分并没有什么卵用。</p><p>对，二分的确没有什么用，但是从它身上衍生出来的二分答案却是一个很有用的东西！</p><p>二分答案，就是通过二分的方式枚举出一个答案来，然后再验证你的查找结果是否正确，从而获取答案</p><h3 id="要求-amp-特点"><a href="#要求-amp-特点" class="headerlink" title="要求&amp;特点"></a>要求&amp;特点</h3><ol><li>答案具有<strong>单调性</strong></li><li>题面里包含与“最小的最大，最大的最小”相关的字眼</li></ol><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li><p>先将给定的序列排序</p></li><li><p>参照二分查找，枚举一个答案mid</p></li><li><p>验证这个答案是否可行</p></li><li><p>如果可行，<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果不可行，```更新边界，继续寻找答案</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>一般模板</p><p>其中的check函数需要针对每一个题目进行验证</p><p>当然你会写暴力枚举的check也可以借鉴过来#(滑稽)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="comment">/* code here*/</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n,m;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">cin</span> &gt;&gt; p[i];</span><br><span class="line">  <span class="comment">// -----------------------------------</span></span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">0</span>,r = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (check(ans))&#123;</span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">      ans = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">// -----------------------------------</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="推荐题目"><a href="#推荐题目" class="headerlink" title="推荐题目"></a>推荐题目</h2><ol><li><a href="https://www.luogu.org/problemnew/show/P2678" target="_blank" rel="noopener">「洛谷P2678 跳房子」</a> 出处：NOIP2015 提高组</li><li><a href="https://www.luogu.org/problemnew/show/P1824" target="_blank" rel="noopener">「洛谷P1824 进击的奶牛」</a> 出处：USACO </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;友情提示：先看二分查找，再看二分答案！&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1102 《A-B数对》</title>
    <link href="https://blog.handwer-std.top/2018-02-01/Luogu-P1102/"/>
    <id>https://blog.handwer-std.top/2018-02-01/Luogu-P1102/</id>
    <published>2018-02-01T13:31:22.000Z</published>
    <updated>2018-07-06T13:41:56.944Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>普及- 的“水”题</p></blockquote><a id="more"></a><p><a href="https://www.luogu.org/problem/show?pid=1102" target="_blank" rel="noopener">题目地址</a> </p><p>提前说明：本题难度为<strong>普及-</strong> </p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出一串数以及一个数字C，要求计算出所有A-B=C的数对的个数。（不同位置的数字一样的数对算不同的数对）</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><p><strong>输入格式</strong>：</p><p>第一行包括2个非负整数N和C，中间用空格隔开。</p><p>第二行有N个整数，中间用空格隔开，作为要求处理的那串数。</p><p><strong>输出格式</strong>：</p><p>输出一行，表示该串数中包含的所有满足A-B=C的数对的个数。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入输出样例1"><a href="#输入输出样例1" class="headerlink" title="输入输出样例1"></a>输入输出样例1</h2><p>input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 1</span><br><span class="line">1 1 2 3</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h1 id="数据说明"><a href="#数据说明" class="headerlink" title="数据说明"></a>数据说明</h1><p>对于73%的数据，N &lt;= 2000；</p><p>对于100%的数据，N &lt;= 200000。</p><p>所有输入数据都在longint范围内。</p><p><strong>原题目</strong>2017/4/29新添数据两组</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>粗略一看，这道题是不是特别水？</p><p>只需要用$O(n^2)$的暴力解法不就可以了吗？</p><p>​        枚举A和B，再判断A-B是否为C</p><p>但是！</p><p>你们Naive，没看见那个<em>N&lt;=200000</em> 吗</p><p>这样肯定会TLE的啊喂</p><p><a href="https://www.luogu.org/record/show?rid=5540782" target="_blank" rel="noopener">测试记录 76分</a></p><h2 id="正确解法"><a href="#正确解法" class="headerlink" title="正确解法"></a>正确解法</h2><p>作为C++选手，我们一定要发扬光大Alexander留给我们的STL</p><p>于是我们就可以用std::map映射来做这道题目（注意这是<strong>普及-</strong>的题目）</p><p>将A-B=C转换为A-C=B，然后找这N个数中有几个B就行了</p><p><a href="https://www.luogu.org/recordnew/show/5555723" target="_blank" rel="noopener">测试记录 AC</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="暴力解法-1"><a href="#暴力解法-1" class="headerlink" title="暴力解法"></a>暴力解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> *arr,n,c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; c;</span><br><span class="line">  arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">      <span class="keyword">if</span> ((arr[i] - arr[j] == c)) ans++;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  read();</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; work() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正确解法-1"><a href="#正确解法-1" class="headerlink" title="正确解法"></a>正确解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">LetMeAccept</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n,c;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;c);</span><br><span class="line">  <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a + i);</span><br><span class="line">    p[a[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    ans += p[a[i] + c];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    LetMeAccept();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;普及- 的“水”题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>图论之建立基础的图</title>
    <link href="https://blog.handwer-std.top/2017-12-31/CreateGraph/"/>
    <id>https://blog.handwer-std.top/2017-12-31/CreateGraph/</id>
    <published>2017-12-31T00:25:31.000Z</published>
    <updated>2018-06-23T00:17:15.609Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>背下来就行了</p></blockquote><a id="more"></a><p>学（背）会建立一个基础的图，是写好图论算法的基础。</p><p>具体就是写一个循环，通过构造函数来创建一个一个的边和结点<br>附代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 2e31-1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">'='</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2500 + 5</span></span><br><span class="line"><span class="comment">//设定图的最大结点值为2500</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  Edge *firstEdge;</span><br><span class="line">  <span class="keyword">int</span> dist;</span><br><span class="line">  <span class="keyword">bool</span> inQueue;</span><br><span class="line">&#125; node[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">  Node *s,*t;</span><br><span class="line">  <span class="keyword">int</span> w; <span class="comment">//权值</span></span><br><span class="line">  Edge *next; <span class="comment">//下一条边</span></span><br><span class="line"></span><br><span class="line">  Edge(Node *s,Node *t,<span class="keyword">int</span> w) : s(s),t(t),w(w),next(s-&gt;firstEdge);</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;s,<span class="keyword">const</span> <span class="keyword">int</span> &amp;t,<span class="keyword">const</span> <span class="keyword">int</span> &amp;w)</span></span>&#123;</span><br><span class="line">  node[s].firstEdge = <span class="keyword">new</span> Edge(&amp;node[s],&amp;node[t],w);</span><br><span class="line">  node[t].firstEdge = <span class="keyword">new</span> Edge(&amp;node[t],&amp;node[s],w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*      code here</span></span><br><span class="line"><span class="comment"> *  请在这里写各种玄学的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> n,m,s,t;</span><br><span class="line">   ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">     <span class="keyword">int</span> u,v,w;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; u,v,w;</span><br><span class="line">     add(u,v,w);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* code here*/</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>好了，这样你就可以把一个<del>简单</del>玄学的图建立起来了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;背下来就行了&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>SPFA</title>
    <link href="https://blog.handwer-std.top/2017-12-30/SPFA/"/>
    <id>https://blog.handwer-std.top/2017-12-30/SPFA/</id>
    <published>2017-12-30T13:05:19.000Z</published>
    <updated>2018-06-23T00:17:15.685Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简单的SPFA最短路模板，适用于图的边权有负数的情况。</p></blockquote><a id="more"></a><h1 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h1><p>我们用数组d记录每个结点的最短路径估计值，而且用邻接表来存储图G。运用动态逼近法：设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行操作，直至队列空为止。</p><h1 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2500 + 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">'='</span> &lt;&lt; x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf = <span class="number">2e31</span><span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">Edge *firstEdge;</span><br><span class="line"><span class="keyword">int</span> dist;</span><br><span class="line"><span class="keyword">bool</span> inQueue;</span><br><span class="line">&#125; node[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">Node *s,*t;</span><br><span class="line"><span class="keyword">int</span> w;</span><br><span class="line">Edge *next;</span><br><span class="line"></span><br><span class="line">Edge(Node *s,Node *t,<span class="keyword">int</span> w) : s(s),t(t),w(w),next(s-&gt;firstEdge)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;s,<span class="keyword">const</span> <span class="keyword">int</span> &amp;t,<span class="keyword">const</span> <span class="keyword">int</span> &amp;w)</span></span>&#123;</span><br><span class="line">  node[s].firstEdge = <span class="keyword">new</span> Edge(&amp;node[s],&amp;node[t],w);</span><br><span class="line">  node[t].firstEdge = <span class="keyword">new</span> Edge(&amp;node[t],&amp;node[s],w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;s,<span class="keyword">const</span> <span class="keyword">int</span> &amp;t,<span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    node[i].dist = Inf;</span><br><span class="line">    node[i].inQueue = <span class="literal">false</span>; <span class="comment">//将所有节点的在队列的情况设为false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">queue</span>&lt;Node *&gt; q;</span><br><span class="line">  q.push(&amp;node[s]);</span><br><span class="line">  node[s].dist = <span class="number">0</span>;</span><br><span class="line">  node[s].inQueue = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">    Node *u = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">u-&gt;inQueue = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Edge *e = u-&gt;firstEdge;e;e = e-&gt;next)&#123;</span><br><span class="line">Node *v = e-&gt;t;</span><br><span class="line"><span class="keyword">if</span> (v-&gt;dist &gt; u-&gt;dist + e-&gt;w)&#123;</span><br><span class="line">v-&gt;dist = u-&gt;dist + e-&gt;w;</span><br><span class="line"><span class="keyword">if</span> (!v-&gt;inQueue)&#123;</span><br><span class="line">q.push(v);</span><br><span class="line">v-&gt;inQueue = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node[t].dist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n,m,s,t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> u,v,w;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">add(u,v,w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,spfa(s,t,n));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简单的SPFA最短路模板，适用于图的边权有负数的情况。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>已锁定的文章</title>
    <link href="https://blog.handwer-std.top/2017-12-30/LockedPage/"/>
    <id>https://blog.handwer-std.top/2017-12-30/LockedPage/</id>
    <published>2017-12-30T12:43:29.000Z</published>
    <updated>2018-06-23T00:17:15.617Z</updated>
    
    <content type="html"><![CDATA[<p>本文转自<a href="&quot;https://blog.shq.github.io/2017/12/30/use-hexo2/&quot;">Shq’s Blog</a><br>原文访问密码：password</p><blockquote><p>Be Safe！</p></blockquote><a id="more"></a><hr><p>即使是最简单的密码功能也足以阻止90%的访问者</p><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>一开始使用Hexo的时候，是喜欢它的简单：因为可以直接编译成纯静态文件，方便部署。可是在使用过程中，又发现诸多不便：也因为它全是纯静态页面。突发奇想，能不能给文章加上一个加密访问的功能……</p><p>在经过实践之后，运用到自己博客中，发现有不少的访客对这个功能甚是感兴趣，所以也就在这里找个时间写写自己加密的小诀窍吧算是。</p><h1 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h1><p>由于 Hexo 最终编译出来的文件是纯静态的，也就意味着文章的所有信息其实还是原封不动展示在页面中的，当你输入一篇文章的网址，所有的内容就已经跟随网络传输过来了。那我博客使用的加密是怎么实现的呢？</p><p>这就要讲到 js 的阻塞机制了，在以往的经验中，当页面中有调用alert();函数的时候，整个页面会停止运行，直到你点击确定之后，页面的中的代码才会继续执行下去。我们这里需要的也是这样一个假象，阻止整个页面的渲染，直到你输入了正确的密码才能让页面继续渲染实际的文章。可是alert只有提醒的功能，没有输入的功能，所以这里要用到的是promt函数。例子参见如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var password = promt(&apos;请输入文章密码&apos;);</span><br><span class="line">alert(password);</span><br></pre></td></tr></table></figure></p><h1 id="三、实践"><a href="#三、实践" class="headerlink" title="三、实践"></a>三、实践</h1><p>究竟要把上述代码加在哪里呢？<br>找到themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件。<br>按道理是添加在任何地方都行，但是推荐加在所有的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">&lt;script&gt;</span><br><span class="line">(function()&#123;</span><br><span class="line">if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123;</span><br><span class="line">if (prompt(&apos;请输入文章密码&apos;,&apos;&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123;</span><br><span class="line">alert(&apos;密码错误！&apos;);</span><br><span class="line">history.back();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>如果你好奇page.password是什么东西，那么恭喜你，你对 Hexo 的结构还是很熟悉的。page这个变量就是你在hexo new的时候生成文件中最顶部的东西，以下我给出这篇文章的头部参考：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">title: Hexo文章简单加密访问</span><br><span class="line">date: 2016-12-01 10:45:29</span><br><span class="line">tags: hexo</span><br><span class="line">categories: 博客</span><br><span class="line">keywords:</span><br><span class="line">- Hexo</span><br><span class="line">- 加密</span><br><span class="line">description: 文章访问密码：password</span><br><span class="line">password: password</span><br></pre></td></tr></table></figure></p><p>这样我们就好像使用静态页面完成了部分只有动态页面能完成的东西。</p><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>本来只是简单的纯静态页面，但是经历不断的更新和改进，便有了静态页面统计访问量的工具；有了静态页面添加评论的工具；甚至有了静态页面进行搜索的功能等等。个人想出来的静态页面加密功能根本算不上技术上的创新，只能说是一点小技巧的应用吧，小技巧也能迷惑住大家的眼睛，也算是喜事一件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转自&lt;a href=&quot;&amp;quot;https://blog.shq.github.io/2017/12/30/use-hexo2/&amp;quot;&quot;&gt;Shq’s Blog&lt;/a&gt;&lt;br&gt;原文访问密码：password&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Be Safe！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
